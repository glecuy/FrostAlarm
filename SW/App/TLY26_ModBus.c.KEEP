/*
 * Reference:

 TLY25/26/27/28/29/35 Communication protocol Userâ€™s manual (Tecnologic S.p.A.)

 */


/* Includes ------------------------------------------------------------------*/
#include <string.h>

#include "main.h"
#include "stm32f1xx_hal.h"
#include "TLY26_ModBus.h"
#include "UART_Printf.h"

extern UART_HandleTypeDef huart2;

volatile uint8_t uart2TxDone;

uint8_t ModBusSlaveAddress;
uint8_t ModBusFrame[MODBUS_MAX_LEN];


void DumpFrame( int len ){
    uint8_t * ptw = ModBusFrame;
    UART_printf( "Frame: %02X ", (int)*ptw++ );
    for ( int i=0 ; i< len -1 ; len++ )
        UART_printf( "%02X ", (int)*ptw++ );
    UART_printf( "\r\n" );
}

/* CRC16-MODBUS calculation
 * From https://community.st.com/ forum
 * Differs with bit order and init value !
 */
unsigned int ModBusCRC16(unsigned char *buf, int len)
{
    unsigned int crc = 0xFFFF;
    for (int pos = 0; pos < len; pos++){
        crc ^= (unsigned int)buf[pos];  // XOR byte into least sig. byte of crc
        for (int i = 8; i != 0; i--) {  // Loop over each bit
            if ((crc & 0x0001) != 0) {  // If the LSB is set
                crc >>= 1;              // Shift right and XOR 0xA001
                crc ^= 0xA001;
            }
            else                        // Else LSB is not set
                crc >>= 1;              // Just shift right
        }
    }
    return crc;
}



bool TLY26_Init( uint8_t slaveAddress ){

    ModBusSlaveAddress = slaveAddress;
    uart2TxDone = 1;

    // Turn ModBus in RX
    HAL_GPIO_WritePin  (MODBUS_TX_ENABLE_Port, MODBUS_TX_ENABLE_Pin, GPIO_PIN_RESET);

    return true;
}


static bool TLY26_ReadFrame( uint16_t * pData, uint16_t n ){
    HAL_StatusTypeDef st;

    memset(ModBusFrame, 0, 16 );
    //st = HAL_UART_Receive(&huart2, ModBusFrame, (n*2), 10);
    st = HAL_UART_Receive(&huart2, ModBusFrame, 10, 100);

    DumpFrame(10);
    //UART_printf( "NB=%d (%02X %02X)\r\n", (int)ModBusFrame[2], (int)ModBusFrame[0], (int)ModBusFrame[1] );

    uint16_t w = ModBusFrame[3]<<8 | ModBusFrame[4]<<0;
    pData[0] = w;
    w = ModBusFrame[5]<<8 | ModBusFrame[6]<<0;
    pData[1] = w;

    // crc
    w = ModBusFrame[8]<<8 | ModBusFrame[9]<<0;

    return ( st == HAL_OK );
}

/*

Communication protocol TLY25/27/28/29/35
 * 3.2 Function 6 - writing a word
*/
bool TLY26_writeWord( uint16_t address, uint16_t Data ){
    HAL_StatusTypeDef st;

    // Build ModBus frame
    ModBusFrame[0] = ModBusSlaveAddress;
    ModBusFrame[1] = 6;                         // Function Write
    ModBusFrame[2] = (uint8_t)(address>>8);     // MSB
    ModBusFrame[3] = (uint8_t)(address&0x00FF); // LSB

    ModBusFrame[4] = (uint8_t)(Data>>8);     // MSB
    ModBusFrame[5] = (uint8_t)(Data&0x00FF); // LSB

    // CRC 16
    unsigned int crc = ModBusCRC16(ModBusFrame, 6);

    /* ! Low order byte of the CRC comes first in the RTU message */
    ModBusFrame[6] = crc & 0x00FF;
    ModBusFrame[7] = crc >> 8;

    HAL_GPIO_WritePin (MODBUS_TX_ENABLE_Port, MODBUS_TX_ENABLE_Pin, GPIO_PIN_SET);

    st = HAL_UART_Transmit_IT(&huart2, ModBusFrame, 8);

    // TODO  Timing !!
    HAL_GPIO_WritePin  (MODBUS_TX_ENABLE_Port, MODBUS_TX_ENABLE_Pin, GPIO_PIN_RESET);

    // Wait for response



    return ( st == HAL_OK );
}

bool TLY26_ReadWords( uint16_t address, uint16_t * pData, uint16_t n ){
    HAL_StatusTypeDef st;
    bool ok = false;

    // Build ModBus frame
    ModBusFrame[0] = ModBusSlaveAddress;
    ModBusFrame[1] = 3;                         // Function 3 - reading of n words
    ModBusFrame[2] = (uint8_t)(address>>8);     // MSB
    ModBusFrame[3] = (uint8_t)(address&0x00FF); // LSB

    ModBusFrame[4] = (uint8_t)(n>>8);     // MSB
    ModBusFrame[5] = (uint8_t)(n&0x00FF); // LSB

    // CRC 16
    unsigned int crc = ModBusCRC16(ModBusFrame, 6);

    /* ! Low order byte of the CRC comes first in the RTU message */
    ModBusFrame[6] = crc & 0x00FF;
    ModBusFrame[7] = crc >> 8;

    UserLED_on();
    HAL_GPIO_WritePin  (MODBUS_TX_ENABLE_Port, MODBUS_TX_ENABLE_Pin, GPIO_PIN_SET);

    st = HAL_UART_Transmit_IT(&huart2, ModBusFrame, 8);

    //while( uart2TxDone == 0 ){
        HAL_Delay(10);
    //}

    //HAL_GPIO_WritePin  (MODBUS_TX_ENABLE_Port, MODBUS_TX_ENABLE_Pin, GPIO_PIN_RESET);
    UserLED_off();

    if ( st == HAL_OK ){

        // Wait for response
        ok = TLY26_ReadFrame( pData, n*2+6 );
    }

    return ok;
}

bool TLY26_WriteWords( uint16_t address, uint16_t * pData, uint16_t n ){
    return false;
}


bool TLY26_Terminate( uint8_t slaveAddress ){
    return true;
}


void TLY26_EndOfRx(void){
}


void TLY26_EndOfTx(void){
    HAL_GPIO_WritePin  (MODBUS_TX_ENABLE_Port, MODBUS_TX_ENABLE_Pin, GPIO_PIN_RESET);
    uart2TxDone = 1;
}

